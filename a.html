
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>ratelimit: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Kyagara/equinox/ratelimit/bucket.go (100.0%)</option>
				
				<option value="file1">github.com/Kyagara/equinox/ratelimit/internal.go (96.9%)</option>
				
				<option value="file2">github.com/Kyagara/equinox/ratelimit/limits.go (92.5%)</option>
				
				<option value="file3">github.com/Kyagara/equinox/ratelimit/ratelimit.go (100.0%)</option>
				
				<option value="file4">github.com/Kyagara/equinox/ratelimit/util.go (97.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package ratelimit

import (
        "sync"
        "time"

        "github.com/rs/zerolog"
)

type Bucket struct {
        // Next reset.
        Next time.Time
        // Current number of tokens, starts at limit.
        Tokens int
        // The limit given in the header without any modifications.
        BaseLimit int
        // Maximum amount of tokens, modified by the LimitUsageFactor.
        Limit int
        // Time interval in seconds.
        Interval         time.Duration
        IntervalOverhead time.Duration
        mutex            sync.Mutex
}

func (b *Bucket) MarshalZerologObject(encoder *zerolog.Event) <span class="cov5" title="4">{
        encoder.Int("tokens", b.Tokens).Int("limit", b.Limit).Dur("interval", b.Interval).Time("next", b.Next)
}</span>

func NewBucket(interval time.Duration, intervalOverhead time.Duration, baseLimit int, limit int, tokens int) *Bucket <span class="cov7" title="9">{
        return &amp;Bucket{
                Next:             time.Now().Add(interval + intervalOverhead),
                Tokens:           tokens,
                BaseLimit:        baseLimit,
                Limit:            limit,
                Interval:         interval,
                IntervalOverhead: intervalOverhead,
                mutex:            sync.Mutex{},
        }
}</span>

// Checks if the 'next' reset is in the past, and if so, resets the bucket tokens and sets the next reset.
func (b *Bucket) Check() <span class="cov10" title="20">{
        now := time.Now()
        if b.Next.Before(now) </span><span class="cov5" title="5">{
                b.Tokens = 0
                b.Next = now.Add(b.Interval + b.IntervalOverhead)
        }</span>
}

// Increments the number of tokens in the bucket and returns if the bucket is rate limited.
func (b *Bucket) IsRateLimited() bool <span class="cov9" title="16">{
        b.Check()
        if b.BaseLimit == 0 </span><span class="cov1" title="1">{
                return false
        }</span>
        <span class="cov9" title="15">b.Tokens++
        return b.Tokens &gt;= b.Limit</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package ratelimit

import (
        "context"
        "net/http"
        "sync"
        "time"

        "github.com/rs/zerolog"
)

type InternalRateLimitStore struct {
        Route            map[string]*Limits
        limitUsageFactor float64
        intervalOverhead time.Duration
        mutex            sync.Mutex
}

func (r *InternalRateLimitStore) Reserve(ctx context.Context, logger zerolog.Logger, route string, methodID string) error <span class="cov10" title="16">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        limits, ok := r.Route[route]
        if !ok </span><span class="cov7" title="7">{
                limits = NewLimits()
                r.Route[route] = limits
        }</span>

        <span class="cov10" title="16">methods, ok := limits.Methods[methodID]
        if !ok </span><span class="cov7" title="7">{
                methods = NewLimit(METHOD_RATE_LIMIT_TYPE)
                limits.Methods[methodID] = methods
        }</span>

        <span class="cov10" title="16">if err := limits.App.checkBuckets(ctx, logger, route, methodID); err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov9" title="15">return methods.checkBuckets(ctx, logger, route, methodID)</span>
}

func (r *InternalRateLimitStore) Update(ctx context.Context, logger zerolog.Logger, route string, methodID string, headers http.Header, delay time.Duration) error <span class="cov7" title="7">{
        r.mutex.Lock()
        defer r.mutex.Unlock()

        limits := r.Route[route]

        // If rate limited, set retry after delay based on the rate limit type
        limitType := headers.Get(RATE_LIMIT_TYPE_HEADER)
        if limitType != "" </span><span class="cov1" title="1">{
                if limitType == APP_RATE_LIMIT_TYPE </span><span class="cov1" title="1">{
                        limits.App.setRetryAfter(delay)
                }</span> else<span class="cov0" title="0"> {
                        limits.Methods[methodID].setRetryAfter(delay)
                }</span>
        }

        <span class="cov7" title="7">appRateLimitHeader := headers.Get(APP_RATE_LIMIT_HEADER)
        methodRateLimitHeader := headers.Get(METHOD_RATE_LIMIT_HEADER)

        if !limits.App.limitsMatch(appRateLimitHeader) </span><span class="cov6" title="6">{
                appRateLimitCountHeader := headers.Get(APP_RATE_LIMIT_COUNT_HEADER)
                limits.App = ParseHeaders(appRateLimitHeader, appRateLimitCountHeader, APP_RATE_LIMIT_TYPE, r.limitUsageFactor, r.intervalOverhead)
                logger.Debug().Str("route", route).Msg("New Application buckets")
        }</span>

        <span class="cov7" title="7">if !limits.Methods[methodID].limitsMatch(methodRateLimitHeader) </span><span class="cov7" title="7">{
                methodRateLimitCountHeader := headers.Get(METHOD_RATE_LIMIT_COUNT_HEADER)
                limits.Methods[methodID] = ParseHeaders(methodRateLimitHeader, methodRateLimitCountHeader, METHOD_RATE_LIMIT_TYPE, r.limitUsageFactor, r.intervalOverhead)
                logger.Debug().Str("route", route).Str("method", methodID).Msg("New Method buckets")
        }</span>

        <span class="cov7" title="7">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ratelimit

import (
        "context"
        "strings"
        "sync"
        "time"

        "github.com/rs/zerolog"
)

// Limits in a route.
type Limits struct {
        App     *Limit
        Methods map[string]*Limit
}

func NewLimits() *Limits <span class="cov6" title="8">{
        return &amp;Limits{
                App:     NewLimit(APP_RATE_LIMIT_TYPE),
                Methods: make(map[string]*Limit, 1),
        }
}</span>

// Represents a collection of buckets and the type of limit (application or method).
type Limit struct {
        limitType  string
        buckets    []*Bucket
        retryAfter time.Duration
        mutex      sync.Mutex
}

func NewLimit(limitType string) *Limit <span class="cov8" title="21">{
        return &amp;Limit{
                buckets:    make([]*Bucket, 0),
                limitType:  limitType,
                retryAfter: 0,
                mutex:      sync.Mutex{},
        }
}</span>

// Checks if any of the buckets provided are rate limited, and if so, blocks until the next reset.
func (l *Limit) checkBuckets(ctx context.Context, logger zerolog.Logger, route string, methodID string) error <span class="cov10" title="31">{
        l.mutex.Lock()
        defer l.mutex.Unlock()

        if l.retryAfter &gt; 0 </span><span class="cov1" title="1">{
                err := WaitN(ctx, time.Now().Add(l.retryAfter), l.retryAfter)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn().Err(err).Msg("Failed to wait for retry after")
                        return err
                }</span>

                <span class="cov1" title="1">l.retryAfter = 0</span>
        }

        // Reverse loop, buckets with higher limits will be checked first
        <span class="cov10" title="31">for i := len(l.buckets) - 1; i &gt;= 0; i-- </span><span class="cov7" title="12">{
                bucket := l.buckets[i]
                bucket.mutex.Lock()

                if bucket.IsRateLimited() </span><span class="cov4" title="4">{
                        logger.Warn().
                                Str("route", route).
                                Str("method_id", methodID).
                                Str("limit_type", l.limitType).
                                Object("bucket", bucket).
                                Msg("Rate limited")

                        err := WaitN(ctx, bucket.Next, time.Until(bucket.Next))
                        if err != nil </span><span class="cov1" title="1">{
                                bucket.mutex.Unlock()
                                logger.Warn().Err(err).Msg("Failed to wait for reset")
                                return err
                        }</span>

                        // next reset is now in the past, so reset the bucket
                        <span class="cov3" title="3">bucket.Check()
                        bucket.Tokens++</span>
                }

                <span class="cov7" title="11">bucket.mutex.Unlock()</span>
        }

        <span class="cov9" title="30">return nil</span>
}

// Checks if the limits given in the header match the current buckets.
func (l *Limit) limitsMatch(limitHeader string) bool <span class="cov7" title="14">{
        if limitHeader == "" </span><span class="cov5" title="6">{
                return false
        }</span>

        <span class="cov6" title="8">limits := strings.Split(limitHeader, ",")
        if len(l.buckets) != len(limits) </span><span class="cov5" title="6">{
                return false
        }</span>

        <span class="cov2" title="2">for i, pair := range limits </span><span class="cov2" title="2">{
                bucket := l.buckets[i]
                if bucket == nil </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov2" title="2">limit, interval := getNumbersFromPair(pair)
                if bucket.BaseLimit != limit || bucket.Interval != interval </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        <span class="cov1" title="1">return true</span>
}

func (l *Limit) setRetryAfter(delay time.Duration) <span class="cov1" title="1">{
        l.mutex.Lock()
        l.retryAfter = delay
        l.mutex.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package ratelimit

import (
        "context"
        "errors"
        "net/http"
        "sync"
        "time"

        "github.com/rs/zerolog"
)

const (
        RATE_LIMIT_TYPE_HEADER = "X-Rate-Limit-Type"
        RETRY_AFTER_HEADER     = "Retry-After"

        APP_RATE_LIMIT_HEADER          = "X-App-Rate-Limit"
        APP_RATE_LIMIT_COUNT_HEADER    = "X-App-Rate-Limit-Count"
        METHOD_RATE_LIMIT_HEADER       = "X-Method-Rate-Limit"
        METHOD_RATE_LIMIT_COUNT_HEADER = "X-Method-Rate-Limit-Count"

        APP_RATE_LIMIT_TYPE     = "application"
        METHOD_RATE_LIMIT_TYPE  = "method"
        SERVICE_RATE_LIMIT_TYPE = "service"

        DEFAULT_RETRY_AFTER = 1 * time.Second
)

var (
        ErrContextDeadlineExceeded = errors.New("waiting would exceed context deadline")

        ErrRateLimitIsDisabled = errors.New("rate limit is disabled")
)

type StoreType string

const (
        InternalRateLimit StoreType = "Internal"
)

type Store interface {
        // Reserves one request for the App and Method buckets in a route.
        //
        // If rate limited, will block until the next bucket reset.
        Reserve(ctx context.Context, logger zerolog.Logger, route string, methodID string) error

        // Creates new buckets in a route with the limits provided in the response headers.
        Update(ctx context.Context, logger zerolog.Logger, route string, methodID string, headers http.Header, delay time.Duration) error
}

type RateLimit struct {
        store     Store
        StoreType StoreType
        // Factor to be applied to the limit. E.g. if set to 0.5, the limit will be reduced by 50%.
        LimitUsageFactor float64
        // Delay, in milliseconds, added to reset intervals.
        IntervalOverhead time.Duration
        Enabled          bool
}

func (r RateLimit) MarshalZerologObject(encoder *zerolog.Event) <span class="cov4" title="3">{
        if r.Enabled </span><span class="cov3" title="2">{
                encoder.Str("store", string(r.StoreType)).Float64("limit_usage_factor", r.LimitUsageFactor).Dur("interval_overhead", r.IntervalOverhead)
        }</span>
}

func NewInternalRateLimit(limitUsageFactor float64, intervalOverhead time.Duration) *RateLimit <span class="cov7" title="8">{
        limitUsageFactor, intervalOverhead = ValidateRateLimitOptions(limitUsageFactor, intervalOverhead)
        return &amp;RateLimit{
                store: &amp;InternalRateLimitStore{
                        Route:            map[string]*Limits{},
                        limitUsageFactor: limitUsageFactor,
                        intervalOverhead: intervalOverhead,
                        mutex:            sync.Mutex{},
                },
                StoreType:        InternalRateLimit,
                LimitUsageFactor: limitUsageFactor,
                IntervalOverhead: intervalOverhead,
                Enabled:          true,
        }
}</span>

func (r *RateLimit) Reserve(ctx context.Context, logger zerolog.Logger, route string, methodID string) error <span class="cov10" title="17">{
        if !r.Enabled </span><span class="cov1" title="1">{
                return ErrRateLimitIsDisabled
        }</span>
        <span class="cov9" title="16">return r.store.Reserve(ctx, logger, route, methodID)</span>
}

func (r *RateLimit) Update(ctx context.Context, logger zerolog.Logger, route string, methodID string, headers http.Header, retryAfter time.Duration) error <span class="cov7" title="8">{
        if !r.Enabled </span><span class="cov1" title="1">{
                return ErrRateLimitIsDisabled
        }</span>
        <span class="cov7" title="7">return r.store.Update(ctx, logger, route, methodID, headers, retryAfter)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package ratelimit

import (
        "context"
        "math"
        "strconv"
        "strings"
        "sync"
        "time"
)

// Checks if the limit usage factor and interval overhead within a valid range.
func ValidateRateLimitOptions(limitUsageFactor float64, intervalOverhead time.Duration) (float64, time.Duration) <span class="cov7" title="8">{
        if limitUsageFactor &lt;= 0.0 || limitUsageFactor &gt; 1.0 </span><span class="cov1" title="1">{
                limitUsageFactor = 0.99
        }</span>

        <span class="cov7" title="8">if intervalOverhead &lt; 0 </span><span class="cov1" title="1">{
                intervalOverhead = time.Second
        }</span>

        <span class="cov7" title="8">return limitUsageFactor, intervalOverhead</span>
}

// Waits for the given duration after checking if the context deadline will be exceeded.
func WaitN(ctx context.Context, estimated time.Time, duration time.Duration) error <span class="cov7" title="8">{
        deadline, ok := ctx.Deadline()
        if ok &amp;&amp; deadline.Before(estimated) </span><span class="cov3" title="2">{
                return ErrContextDeadlineExceeded
        }</span>

        <span class="cov6" title="6">select </span>{
        case &lt;-time.After(duration):<span class="cov6" title="5"></span>
        case &lt;-ctx.Done():<span class="cov1" title="1">
                return ctx.Err()</span>
        }

        <span class="cov6" title="5">return nil</span>
}

// Returns the time.Duration in seconds to wait from the Retry-After header, DEFAULT_RETRY_AFTER if not found.
func GetRetryAfterHeader(retryAfterHeader string) time.Duration <span class="cov4" title="3">{
        if retryAfterHeader == "" </span><span class="cov1" title="1">{
                return DEFAULT_RETRY_AFTER
        }</span>

        <span class="cov3" title="2">delayF, err := strconv.Atoi(retryAfterHeader)
        if err != nil </span><span class="cov1" title="1">{
                return DEFAULT_RETRY_AFTER
        }</span>

        <span class="cov1" title="1">return time.Duration(delayF) * time.Second</span>
}

// Parses the headers and returns a new Limit with its buckets.
func ParseHeaders(limitHeader string, countHeader string, limitType string, limitUsageFactor float64, intervalOverhead time.Duration) *Limit <span class="cov8" title="13">{
        if limitHeader == "" || countHeader == "" </span><span class="cov6" title="6">{
                return NewLimit(limitType)
        }</span>

        <span class="cov7" title="7">limits := strings.Split(limitHeader, ",")
        counts := strings.Split(countHeader, ",")

        if len(limits) == 0 </span><span class="cov0" title="0">{
                return NewLimit(limitType)
        }</span>

        <span class="cov7" title="7">limit := &amp;Limit{
                buckets:    make([]*Bucket, len(limits)),
                limitType:  limitType,
                retryAfter: 0,
                mutex:      sync.Mutex{},
        }

        for i, limitString := range limits </span><span class="cov7" title="8">{
                baseLimit, interval := getNumbersFromPair(limitString)
                newLimit := int(math.Max(1, float64(baseLimit)*limitUsageFactor))
                count, _ := getNumbersFromPair(counts[i])
                limit.buckets[i] = NewBucket(interval, intervalOverhead, baseLimit, newLimit, count)
        }</span>

        <span class="cov7" title="7">return limit</span>
}

// Returns the limit and interval in seconds from a pair of numbers separated by a colon.
func getNumbersFromPair(pair string) (int, time.Duration) <span class="cov10" title="18">{
        numbers := strings.Split(pair, ":")
        interval, _ := strconv.Atoi(numbers[1])
        limitOrCount, _ := strconv.Atoi(numbers[0])
        return limitOrCount, time.Duration(interval) * time.Second
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
