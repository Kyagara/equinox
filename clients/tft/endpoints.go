package tft

///////////////////////////////////////////////
//                                           //
//                     !                     //
//   This file is automatically generated!   //
//           Do not directly edit!           //
//                                           //
///////////////////////////////////////////////

// Spec version = 2099d6a309eb237d31b9c5fc1071c36eca85d91f

import (
	"context"
	"fmt"
	"net/http"

	"github.com/Kyagara/equinox/api"
	"github.com/Kyagara/equinox/internal"
	"go.uber.org/zap"
)

// # Riot API Reference
//
// [tft-league-v1]
//
// Note: this struct is automatically generated.
//
// [tft-league-v1]: https://developer.riotgames.com/apis#tft-league-v1
type LeagueV1 struct {
	internal *internal.InternalClient
}

// Get the challenger league.
//
// # Parameters
//   - `route` - Route to query.
//   - `queue` (optional, in query) - Defaults to RANKED_TFT.
//
// # Riot API Reference
//
// [tft-league-v1.getChallengerLeague]
//
// Note: this method is automatically generated.
//
// [tft-league-v1.getChallengerLeague]: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getChallengerLeague
func (e *LeagueV1) ChallengerByQueue(ctx context.Context, route PlatformRoute, queue string) (*LeagueListV1DTO, error) {
	logger := e.internal.Logger("TFT_LeagueV1_ChallengerByQueue")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, "/tft/league/v1/challenger", "tft-league-v1.getChallengerLeague", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	values := equinoxReq.Request.URL.Query()
	if queue != "" {
		values.Set("queue", queue)
	}
	equinoxReq.Request.URL.RawQuery = values.Encode()
	var data LeagueListV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get league entries for a given summoner ID.
//
// # Parameters
//   - `route` - Route to query.
//   - `summonerId` (required, in path)
//
// # Riot API Reference
//
// [tft-league-v1.getLeagueEntriesForSummoner]
//
// Note: this method is automatically generated.
//
// [tft-league-v1.getLeagueEntriesForSummoner]: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueEntriesForSummoner
func (e *LeagueV1) SummonerEntries(ctx context.Context, route PlatformRoute, summonerId string) ([]LeagueEntryV1DTO, error) {
	logger := e.internal.Logger("TFT_LeagueV1_SummonerEntries")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/league/v1/entries/by-summoner/%v", summonerId), "tft-league-v1.getLeagueEntriesForSummoner", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return *new([]LeagueEntryV1DTO), err
	}
	var data []LeagueEntryV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return *new([]LeagueEntryV1DTO), err
	}
	logger.Debug("Method executed successfully")
	return data, nil
}

// Get all the league entries.
//
// # Parameters
//   - `route` - Route to query.
//   - `tier` (required, in path)
//   - `division` (required, in path)
//   - `queue` (optional, in query) - Defaults to RANKED_TFT.
//   - `page` (optional, in query) - Defaults to 1. Starts with page 1.
//
// # Riot API Reference
//
// [tft-league-v1.getLeagueEntries]
//
// Note: this method is automatically generated.
//
// [tft-league-v1.getLeagueEntries]: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueEntries
func (e *LeagueV1) Entries(ctx context.Context, route PlatformRoute, tier Tier, division string, queue string, page int32) ([]LeagueEntryV1DTO, error) {
	logger := e.internal.Logger("TFT_LeagueV1_Entries")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/league/v1/entries/%v/%v", tier, division), "tft-league-v1.getLeagueEntries", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return *new([]LeagueEntryV1DTO), err
	}
	values := equinoxReq.Request.URL.Query()
	if queue != "" {
		values.Set("queue", queue)
	}
	if page != -1 {
		values.Set("page", fmt.Sprint(page))
	}
	equinoxReq.Request.URL.RawQuery = values.Encode()
	var data []LeagueEntryV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return *new([]LeagueEntryV1DTO), err
	}
	logger.Debug("Method executed successfully")
	return data, nil
}

// Get the grandmaster league.
//
// # Parameters
//   - `route` - Route to query.
//   - `queue` (optional, in query) - Defaults to RANKED_TFT.
//
// # Riot API Reference
//
// [tft-league-v1.getGrandmasterLeague]
//
// Note: this method is automatically generated.
//
// [tft-league-v1.getGrandmasterLeague]: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getGrandmasterLeague
func (e *LeagueV1) GrandmasterByQueue(ctx context.Context, route PlatformRoute, queue string) (*LeagueListV1DTO, error) {
	logger := e.internal.Logger("TFT_LeagueV1_GrandmasterByQueue")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, "/tft/league/v1/grandmaster", "tft-league-v1.getGrandmasterLeague", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	values := equinoxReq.Request.URL.Query()
	if queue != "" {
		values.Set("queue", queue)
	}
	equinoxReq.Request.URL.RawQuery = values.Encode()
	var data LeagueListV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get league with given ID, including inactive entries.
//
// # Parameters
//   - `route` - Route to query.
//   - `leagueId` (required, in path) - The UUID of the league.
//
// # Riot API Reference
//
// [tft-league-v1.getLeagueById]
//
// Note: this method is automatically generated.
//
// [tft-league-v1.getLeagueById]: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getLeagueById
func (e *LeagueV1) ByID(ctx context.Context, route PlatformRoute, leagueId string) (*LeagueListV1DTO, error) {
	logger := e.internal.Logger("TFT_LeagueV1_ByID")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/league/v1/leagues/%v", leagueId), "tft-league-v1.getLeagueById", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	var data LeagueListV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get the master league.
//
// # Parameters
//   - `route` - Route to query.
//   - `queue` (optional, in query) - Defaults to RANKED_TFT.
//
// # Riot API Reference
//
// [tft-league-v1.getMasterLeague]
//
// Note: this method is automatically generated.
//
// [tft-league-v1.getMasterLeague]: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getMasterLeague
func (e *LeagueV1) MasterByQueue(ctx context.Context, route PlatformRoute, queue string) (*LeagueListV1DTO, error) {
	logger := e.internal.Logger("TFT_LeagueV1_MasterByQueue")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, "/tft/league/v1/master", "tft-league-v1.getMasterLeague", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	values := equinoxReq.Request.URL.Query()
	if queue != "" {
		values.Set("queue", queue)
	}
	equinoxReq.Request.URL.RawQuery = values.Encode()
	var data LeagueListV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get the top rated ladder for given queue
//
// # Parameters
//   - `route` - Route to query.
//   - `queue` (required, in path)
//
// # Riot API Reference
//
// [tft-league-v1.getTopRatedLadder]
//
// Note: this method is automatically generated.
//
// [tft-league-v1.getTopRatedLadder]: https://developer.riotgames.com/api-methods/#tft-league-v1/GET_getTopRatedLadder
func (e *LeagueV1) TopRatedLadder(ctx context.Context, route PlatformRoute, queue QueueType) ([]TopRatedLadderEntryV1DTO, error) {
	logger := e.internal.Logger("TFT_LeagueV1_TopRatedLadder")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/league/v1/rated-ladders/%v/top", queue), "tft-league-v1.getTopRatedLadder", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return *new([]TopRatedLadderEntryV1DTO), err
	}
	var data []TopRatedLadderEntryV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return *new([]TopRatedLadderEntryV1DTO), err
	}
	logger.Debug("Method executed successfully")
	return data, nil
}

// # Riot API Reference
//
// [tft-match-v1]
//
// Note: this struct is automatically generated.
//
// [tft-match-v1]: https://developer.riotgames.com/apis#tft-match-v1
type MatchV1 struct {
	internal *internal.InternalClient
}

// Get a list of match ids by PUUID
//
// # Parameters
//   - `route` - Route to query.
//   - `puuid` (required, in path)
//   - `start` (optional, in query) - Defaults to 0. Start index.
//   - `endTime` (optional, in query) - Epoch timestamp in seconds.
//   - `startTime` (optional, in query) - Epoch timestamp in seconds. The matchlist started storing timestamps on June 16th, 2021. Any matches played before June 16th, 2021 won't be included in the results if the startTime filter is set.
//   - `count` (optional, in query) - Defaults to 20. Number of match ids to return.
//
// # Riot API Reference
//
// [tft-match-v1.getMatchIdsByPUUID]
//
// Note: this method is automatically generated.
//
// [tft-match-v1.getMatchIdsByPUUID]: https://developer.riotgames.com/api-methods/#tft-match-v1/GET_getMatchIdsByPUUID
func (e *MatchV1) ListByPUUID(ctx context.Context, route api.RegionalRoute, puuid string, start int32, endTime int64, startTime int64, count int32) ([]string, error) {
	logger := e.internal.Logger("TFT_MatchV1_ListByPUUID")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/match/v1/matches/by-puuid/%v/ids", puuid), "tft-match-v1.getMatchIdsByPUUID", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return *new([]string), err
	}
	values := equinoxReq.Request.URL.Query()
	if start != -1 {
		values.Set("start", fmt.Sprint(start))
	}
	if endTime != -1 {
		values.Set("endTime", fmt.Sprint(endTime))
	}
	if startTime != -1 {
		values.Set("startTime", fmt.Sprint(startTime))
	}
	if count != -1 {
		values.Set("count", fmt.Sprint(count))
	}
	equinoxReq.Request.URL.RawQuery = values.Encode()
	var data []string
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return *new([]string), err
	}
	logger.Debug("Method executed successfully")
	return data, nil
}

// Get a match by match id
//
// # Parameters
//   - `route` - Route to query.
//   - `matchId` (required, in path)
//
// # Riot API Reference
//
// [tft-match-v1.getMatch]
//
// Note: this method is automatically generated.
//
// [tft-match-v1.getMatch]: https://developer.riotgames.com/api-methods/#tft-match-v1/GET_getMatch
func (e *MatchV1) ByID(ctx context.Context, route api.RegionalRoute, matchId string) (*MatchV1DTO, error) {
	logger := e.internal.Logger("TFT_MatchV1_ByID")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/match/v1/matches/%v", matchId), "tft-match-v1.getMatch", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	var data MatchV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// # Riot API Reference
//
// [tft-status-v1]
//
// Note: this struct is automatically generated.
//
// [tft-status-v1]: https://developer.riotgames.com/apis#tft-status-v1
type StatusV1 struct {
	internal *internal.InternalClient
}

// Get Teamfight Tactics status for the given platform.
//
// # Parameters
//   - `route` - Route to query.
//
// # Riot API Reference
//
// [tft-status-v1.getPlatformData]
//
// Note: this method is automatically generated.
//
// [tft-status-v1.getPlatformData]: https://developer.riotgames.com/api-methods/#tft-status-v1/GET_getPlatformData
func (e *StatusV1) Platform(ctx context.Context, route PlatformRoute) (*PlatformDataV1DTO, error) {
	logger := e.internal.Logger("TFT_StatusV1_Platform")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, "/tft/status/v1/platform-data", "tft-status-v1.getPlatformData", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	var data PlatformDataV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// # Riot API Reference
//
// [tft-summoner-v1]
//
// Note: this struct is automatically generated.
//
// [tft-summoner-v1]: https://developer.riotgames.com/apis#tft-summoner-v1
type SummonerV1 struct {
	internal *internal.InternalClient
}

// Get a summoner by account ID.
//
// # Parameters
//   - `route` - Route to query.
//   - `encryptedAccountId` (required, in path)
//
// # Riot API Reference
//
// [tft-summoner-v1.getByAccountId]
//
// Note: this method is automatically generated.
//
// [tft-summoner-v1.getByAccountId]: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getByAccountId
func (e *SummonerV1) ByAccountID(ctx context.Context, route PlatformRoute, encryptedAccountId string) (*SummonerV1DTO, error) {
	logger := e.internal.Logger("TFT_SummonerV1_ByAccountID")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/summoner/v1/summoners/by-account/%v", encryptedAccountId), "tft-summoner-v1.getByAccountId", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	var data SummonerV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get a summoner by summoner name.
//
// # Parameters
//   - `route` - Route to query.
//   - `summonerName` (required, in path) - Summoner Name
//
// # Riot API Reference
//
// [tft-summoner-v1.getBySummonerName]
//
// Note: this method is automatically generated.
//
// [tft-summoner-v1.getBySummonerName]: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getBySummonerName
func (e *SummonerV1) ByName(ctx context.Context, route PlatformRoute, summonerName string) (*SummonerV1DTO, error) {
	logger := e.internal.Logger("TFT_SummonerV1_ByName")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/summoner/v1/summoners/by-name/%v", summonerName), "tft-summoner-v1.getBySummonerName", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	var data SummonerV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get a summoner by PUUID.
//
// # Parameters
//   - `route` - Route to query.
//   - `encryptedPUUID` (required, in path) - Summoner ID
//
// # Riot API Reference
//
// [tft-summoner-v1.getByPUUID]
//
// Note: this method is automatically generated.
//
// [tft-summoner-v1.getByPUUID]: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getByPUUID
func (e *SummonerV1) ByPUUID(ctx context.Context, route PlatformRoute, encryptedPUUID string) (*SummonerV1DTO, error) {
	logger := e.internal.Logger("TFT_SummonerV1_ByPUUID")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/summoner/v1/summoners/by-puuid/%v", encryptedPUUID), "tft-summoner-v1.getByPUUID", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	var data SummonerV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get a summoner by access token.
//
// # Parameters
//   - `route` - Route to query.
//   - `authorization` (optional, in header) - Bearer token.
//
// # Riot API Reference
//
// [tft-summoner-v1.getByAccessToken]
//
// Note: this method is automatically generated.
//
// [tft-summoner-v1.getByAccessToken]: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getByAccessToken
func (e *SummonerV1) ByAccessToken(ctx context.Context, route PlatformRoute, authorization string) (*SummonerV1DTO, error) {
	logger := e.internal.Logger("TFT_SummonerV1_ByAccessToken")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, "/tft/summoner/v1/summoners/me", "tft-summoner-v1.getByAccessToken", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	if authorization == "" {
		return new(SummonerV1DTO), fmt.Errorf("'authorization' header is required")
	}
	equinoxReq.Request.Header.Set("authorization", authorization)
	var data SummonerV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}

// Get a summoner by summoner ID.
//
// # Parameters
//   - `route` - Route to query.
//   - `encryptedSummonerId` (required, in path) - Summoner ID
//
// # Riot API Reference
//
// [tft-summoner-v1.getBySummonerId]
//
// Note: this method is automatically generated.
//
// [tft-summoner-v1.getBySummonerId]: https://developer.riotgames.com/api-methods/#tft-summoner-v1/GET_getBySummonerId
func (e *SummonerV1) BySummonerID(ctx context.Context, route PlatformRoute, encryptedSummonerId string) (*SummonerV1DTO, error) {
	logger := e.internal.Logger("TFT_SummonerV1_BySummonerID")
	logger.Debug("Method started execution")
	equinoxReq, err := e.internal.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.MethodGet, route, fmt.Sprintf("/tft/summoner/v1/summoners/%v", encryptedSummonerId), "tft-summoner-v1.getBySummonerId", nil)
	if err != nil {
		logger.Error("Error creating request", zap.Error(err))
		return nil, err
	}
	var data SummonerV1DTO
	err = e.internal.Execute(ctx, equinoxReq, &data)
	if err != nil {
		logger.Error("Error executing request", zap.Error(err))
		return nil, err
	}
	logger.Debug("Method executed successfully")
	return &data, nil
}
