package main

import (
	"fmt"
	"regexp"
	"slices"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/tidwall/gjson"
)

var (
	goTypes = []string{
		"bool",
		"string",
		"int32",
		"int64",
		"float32",
		"float64",
		"any",
	}

	digitRegex   = regexp.MustCompile(`^\d`)
	versionRegex = regexp.MustCompile(`v.*\d`)
	clientRegex  = regexp.MustCompile("(?i)(lor|riot|val|lol|tft)")
	mapTypeRegex = regexp.MustCompile(`\](.+)`)
)

func preamble(packageName string, version string) string {
	return fmt.Sprintf(`package %s

///////////////////////////////////////////////
//                                           //
//                     !                     //
//   This file is automatically generated!   //
//           Do not directly edit!           //
//                                           //
///////////////////////////////////////////////

// Spec version = %v`, packageName, version)
}

func filterTFT(table map[string]GenericConstant, removeTFT bool) map[string]GenericConstant {
	newTable := make(map[string]GenericConstant, len(table))
	keywords := []string{"tft", "teamfight", "convergence"}
	for name, v := range table {
		containsTFT := false
		for _, keyword := range keywords {
			if strings.Contains(strings.ToLower(v.Description), keyword) {
				containsTFT = true
				break
			}
		}
		if removeTFT && !containsTFT {
			newTable[name] = v
		} else if !removeTFT && containsTFT {
			newTable[name] = v
		}
	}
	return newTable
}

func getEndpointGroup(clientName string, spec gjson.Result) map[string][]EndpointGroup {
	endpoints := make(map[string][]EndpointGroup)

	paths := spec.Get("paths").Map()
	for path, endpoint := range paths {
		parts := strings.Split(path, "/")
		endpointName := endpoint.Get("x-endpoint").String()

		if parts[1] == clientName || (parts[1] == "fulfillment" && clientName == "lol") || (strings.Contains(endpointName, "tft") && clientName == "tft") {
			if clientName == "lol" && strings.Contains(endpointName, "tft") {
				continue
			}
			endpoints[endpointName] = append(endpoints[endpointName], EndpointGroup{path, endpoint})
		}
	}

	return endpoints
}

func filterEndpointGroup(endpointGroup map[string][]EndpointGroup, schemas gjson.Result) map[string][]string {
	schemaKeyByEndpoint := make(map[string][]string)

	apis := make([]string, 0, len(endpointGroup))
	for key := range endpointGroup {
		if key != "Error" {
			apis = append(apis, key)
		}
	}

	for schemaKey := range schemas.Map() {
		if schemaKey != "Error" {
			parts := strings.Split(schemaKey, ".")
			groupKey := parts[0]
			if slices.Contains(apis, groupKey) {
				schemaKeyByEndpoint[groupKey] = append(schemaKeyByEndpoint[groupKey], schemaKey)
			}
		}
	}

	return schemaKeyByEndpoint
}

func removeGameName(str string) string {
	return clientRegex.ReplaceAllString(str, "")
}

func getNormalizedClientName(clientName string) string {
	if clientName == "riot" {
		return "Riot"
	} else {
		return strings.ToUpper(clientName)
	}
}

func formatEndpointName(endpointName string) string {
	var name strings.Builder

	for _, item := range strings.Split(endpointName, "-") {
		if clientRegex.MatchString(item) {
			continue
		}
		name.WriteString(strcase.ToCamel(item))
	}

	return name.String()
}

func normalizeDTOName(dto string, version string) (string, string) {
	if len(version) > 2 {
		version = version[len(version)-2:]
	}

	dto = strings.ReplaceAll(dto, "Dto", "")
	dto = strings.ReplaceAll(dto, "DTO", "")
	dto = strings.ReplaceAll(dto, version, "")
	dto = strings.Replace(dto, "ChampionInfo", "ChampionRotation", 1)

	dto += version + "DTO"
	for _, v := range goTypes {
		if strings.HasSuffix(dto, v+version+"DTO") {
			dto = strings.Replace(dto, version+"DTO", "", 1)
			break
		}
	}

	return dto, version
}

func stringifyType(prop gjson.Result) string {
	if prop.Get("anyOf").Exists() {
		prop = prop.Get("anyOf").Array()[0]
	}

	enumType := prop.Get("x-enum").String()
	if enumType != "" && enumType != "locale" {
		if enumType == "champion" {
			return prop.Get("format").String()
		}

		propType := prop.Get("x-type").String()
		if propType == "" {
			enumType = strcase.ToCamel(enumType)
		}

		if propType == "string" {
			return strcase.ToCamel(enumType)
		}

		return prop.Get("format").String()
	}

	refType := prop.Get("$ref").String()
	if refType != "" {
		return refType[strings.LastIndex(refType, ".")+1:]
	}

	propType := prop.Get("type").String()
	if propType != "" {
		switch propType {
		case "boolean":
			return "bool"
		case "integer":
			if prop.Get("format").String() == "int32" {
				return "int32"
			}

			return "int64"
		case "number":
			if prop.Get("format").String() == "float" {
				return "float32"
			}

			return "float64"
		case "array":
			return "[]" + stringifyType(prop.Get("items"))
		case "string":
			return "string"
		case "object":
			// For undocumented props that only have {"type": "object"}
			// From https://github.com/MingweiSamuel/Riven/commit/6ee5687437dac9f27f18a119dd0def15b0bd4602
			if len(prop.Map()) == 1 {
				return "map[string]any"
			}

			keyType := stringifyType(prop.Get("x-key"))
			valueType := stringifyType(prop.Get("additionalProperties"))
			return "map[" + keyType + "]" + valueType
		default:
			return propType
		}
	}

	return ""
}

func cleanDTOPropType(prop gjson.Result, version string, endpoint string, propType string) string {
	if !slices.Contains(goTypes, propType) && !prop.Get("x-enum").Exists() {
		for _, pType := range goTypes {
			if strings.HasSuffix(propType, pType) {
				return propType
			}
		}

		propType, _ = normalizeDTOName(propType, version)

		endpoint = clientRegex.ReplaceAllString(endpoint, "")
		endpoint = endpoint[:len(endpoint)-3]
		endpoint = strcase.ToCamel(endpoint)

		if strings.HasPrefix(propType, "[]") {
			raw := propType[2:]

			if slices.Contains(goTypes, raw) {
				return propType
			}

			propType = strings.Replace(propType, propType, "[]"+endpoint+raw, 1)

			if strings.Contains(propType, endpoint+endpoint) {
				return strings.Replace(propType, endpoint+endpoint, endpoint, 1)
			}

			return propType
		}

		if strings.Contains(propType, "map") {
			match := mapTypeRegex.FindStringSubmatch(propType)
			new := strings.Replace(propType, "]"+match[1], "]"+endpoint+match[1], 1)
			// Replacing potential MatchMatchTimeline...
			if strings.Contains(new, endpoint+endpoint) {
				return strings.Replace(new, endpoint+endpoint, endpoint, 1)
			}
			return new
		}

		if endpoint == "TournamentStub" && strings.HasPrefix(propType, "Tournament") {
			propType = strings.Replace(propType, "Tournament", "", 1)
		}

		if !strings.HasPrefix(propType, endpoint) {
			propType = endpoint + propType
		}
	}

	return propType
}
