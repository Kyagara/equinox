const changeCase = require('change-case')

const versionReg = /V.*\d/
const clientReg = /(Lor|Riot|Val|Lol|Tft)/
const spec = require('./specs/spec.json')
const methodNamesMapping = {
  CurrentGameInfoBySummoner: 'CurrentGameBySummonerID',
  ChampionMasteryScoreByPUUID: 'MasteryScoreByPUUID',
  AllChampionMasteriesByPUUID: 'AllMasteriesByPUUID',
  ChampionMasteryByPUUID: 'MasteryByPUUID',
  TopChampionMasteriesByPUUID: 'TopMasteriesByPUUID',
  AllChampionMasteries: 'AllMasteriesBySummonerID',
  ChampionMastery: 'MasteryBySummonerID',
  TopChampionMasteries: 'TopMasteriesBySummonerID',
  ChampionMasteryScore: 'ScoreBySummonerID',
  PlayersByPUUID: 'SummonerEntriesByPUUID',
  PlayersBySummoner: 'SummonerEntriesBySummonerID',
  FeaturedGames: 'Featured',
  ShardData: 'Shard',
  TeamByID: 'TeamByTeamID',
  ChampionInfo: 'Rotation',
  BySummonerName: 'ByName',
  MatchIdsByPUUID: 'ListByPUUID',
  Matchlist: 'ListByPUUID',
  Configs: 'ConfigByID',
  PlayerData: 'ByPUUID',
  PlatformData: 'Platform',
  EntriesForSummoner: 'SummonerEntries',
  Challenger: 'ChallengerByQueue',
  Grandmaster: 'GrandmasterByQueue',
  Master: 'MasterByQueue',
  TournamentByID: 'ByID',
  TournamentByTeam: 'ByTeamID',
  Match: 'ByID',
}

// flatMap: https://gist.github.com/samgiles/762ee337dff48623e729
// [B](f: (A) â‡’ [B]): [B]  ; Although the types in the arrays aren't strict (:
Array.prototype.groupBy = function (lambda) {
  return Object.entries(
    this.reduce((agg, x) => {
      const k = lambda(x)
      ;(agg[k] = agg[k] || []).push(x)
      return agg
    }, {}),
  )
}
Array.prototype.sortBy = function (lambda) {
  return this.sort((a, b) => {
    const va = lambda(a)
    const vb = lambda(b)
    if (typeof va !== typeof vb) throw Error(`Mismatched sort types: ${typeof va}, ${typeof vb}.`)
    if (typeof va === 'number') return va - vb
    if (typeof va === 'string') return va.localeCompare(vb)
    throw Error(`Unknown sort type: ${typeof va}.`)
  })
}

function preamble(packageName, version) {
  return `\
package ${packageName}

///////////////////////////////////////////////
//                                           //
//                     !                     //
//   This file is automatically generated!   //
//           Do not directly edit!           //
//                                           //
///////////////////////////////////////////////

// Spec version = ${version}`
}

function getClientEndpoints(clientName) {
  const endpoints = {}
  const clientAPIs = Object.entries(spec.paths).filter(([path]) => {
    const api = path.split('/')[1]
    return api === clientName || (api === 'fulfillment' && clientName === 'lol')
  })
  clientAPIs.forEach(([path, endpoint]) => {
    const endpointName = endpoint['x-endpoint']
    endpoints[endpointName] = endpoints[endpointName] || []
    endpoints[endpointName].push([path, endpoint])
  })
  return endpoints
}

function removeClientName(clientName) {
  return clientName.replace(clientReg, '')
}

function getNormalizedDTOStructName(name, version, endpoint) {
  version = versionReg.exec(version)[0].slice(-2)
  let temp = name.replace('DTO', `${version}DTO`)
  temp = temp.replace(`${version}${version}DTO`, `${version}DTO`)
  if (endpoint !== null && endpoint.includes('tournament') && endpoint.includes('stub')) {
    if (
      temp.startsWith('Tournament') ||
      temp.startsWith('LobbyEvent') ||
      temp.startsWith('Provider')
    ) {
      temp = 'Stub' + temp
    }
  }
  if (endpoint !== null) {
    if (
      endpoint.startsWith('league-exp') &&
      (temp.startsWith('League') || temp.startsWith('Mini'))
    ) {
      temp = 'Exp' + temp
    }
    if (endpoint.startsWith('val-ranked') && temp.startsWith('Player')) {
      temp = 'Match' + temp
    }
    if (endpoint.startsWith('lor-ranked') && temp.startsWith('Player')) {
      temp = 'Leaderboard' + temp
    }
    if (endpoint.startsWith('val-status') && temp.startsWith('Content')) {
      temp = 'Status' + temp
    }
  }
  temp = temp.replace(`${version}DTOWrapperDTO`, 'Wrapper' + version + 'DTO')
  temp = temp.replace('ChampionInfoV', 'ChampionRotationV')
  return temp
}

function getNormalizedFieldName(name) {
  let temp = changeCase.pascalCase(name.replace('-', ''))
  switch (temp) {
    case 'Puuid':
      return 'PUUID'
    case 'Xp':
      return 'XP'
    case 'Id':
      return 'ID'
    default:
      if (temp.endsWith('Id')) {
        temp = temp.slice(0, temp.length - 2) + 'ID'
      }
      if (temp.includes('Ids')) {
        temp = temp.replace('Ids', 'IDs')
      }
      return temp
  }
}

function normalizeSchemaName(name) {
  if (!name.endsWith('DTO') && !name.endsWith('Dto')) {
    return name + 'DTO'
  }
  return name.replace('Dto', 'DTO')
}

function normalizeMethodName(method) {
  let temp = method.replace(/^Get/, '')
  temp = temp.replace(/League/g, '')
  temp = temp.replace(/Challenge(?!r)/g, '')
  temp = temp.replace(/Id$/, 'ID')
  temp = temp.replace(/Puuid$/, 'PUUID')
  temp = temp.replace(/Rsopuuid$/, 'RSOPUUID')
  return methodNamesMapping[temp] || temp
}

function capitalize(input) {
  return input[0].toUpperCase() + input.slice(1)
}

function normalizePropName(propName) {
  let out = propName
  // No leading digits.
  if (/^\d/.test(out)) {
    out = 'x' + out
  }
  if (out === 'Authorization') return 'authorization'
  if (out === 'type') return out + '_'
  return out
}

function stringifyType(prop) {
  if (prop.anyOf) {
    prop = prop.anyOf[0]
  }

  const enumType = prop['x-enum']
  if (enumType && enumType !== 'locale') {
    const type = prop['x-type']
    if (enumType === 'champion') return !prop.format ? 'int64' : prop.format
    if (!type) {
      changeCase.pascalCase(enumType)
    }
    if (type === 'string') {
      return changeCase.pascalCase(enumType)
    }
    return prop.format
  }

  const refType = prop.$ref
  if (refType) {
    return normalizeSchemaName(refType.slice(refType.indexOf('.') + 1))
  }

  switch (prop.type) {
    case 'boolean':
      return 'bool'
    case 'integer':
      return prop.format === 'int32' ? 'int32' : 'int64'
    case 'number':
      return prop.format === 'float' ? 'float32' : 'float64'
    case 'array':
      return `[]${stringifyType(prop.items)}`
    case 'string':
      return 'string'
    case 'object':
      return `map[${stringifyType(prop['x-key'])}]${stringifyType(prop.additionalProperties)}`
    default:
      return prop.type
  }
}

function formatJsonProperty(name) {
  return `\`json:"${name},omitempty"\``
}

function formatAddQueryParam(param) {
  const name = normalizePropName(param.name)
  const prop = param.schema
  let letHeaderName = name
  if (name.endsWith('_')) {
    letHeaderName = name.slice(0, -1)
  }
  let condition
  if (prop.type === 'string') {
    condition = `${name} != ""`
  } else if (prop.type === 'integer') {
    condition = `${name} != -1`
  } else {
    throw new Error(`${prop.type} not supported`)
  }
  if (prop.type === 'string') {
    return `if ${condition} {
    values.Set("${letHeaderName}", ${name})
  }`
  }
  return `if ${condition} {
    values.Set("${letHeaderName}", fmt.Sprint(${name}))
  }`
}

function formatAddHeaderParam(param, returnValue, isPrimitive) {
  const name = normalizePropName(param.name)
  let value = `new(${returnValue})`
  if (isPrimitive) value = '*' + value
  const letHeaderName = name.endsWith('_') ? name.slice(0, -1) : name
  switch (param.schema.type) {
    case 'string':
      return `if ${name} == "" {
    return ${value}, fmt.Errorf("'${name}' header is required")
  }
  request.Header.Set("${letHeaderName}", fmt.Sprint(${name}))`
    default:
      throw new Error(`${param.schema.type} not supported`)
  }
}

function formatRouteArgument(route, pathParams = []) {
  if (!pathParams.length) return `"${route}"`
  const args = pathParams.map(({ name }) => name)
  const formattedRoute = route.replace(/\{\S+?\}/g, '%v')
  const formattedArgs = args.join(', ')
  return `fmt.Sprintf("${formattedRoute}", ${formattedArgs})`
}

function getFullAPIName(name) {
  switch (name) {
    case "LOL":
      return "League of Legends"
    case "VAL":
      return "VALORANT"
    case "LOR":
      return "Legends of Runeterra"
    case "Riot":
      return "Riot Games"
    case "TFT":
      return "Teamfight Tactics"
    default:
      return name
  }
}

module.exports = {
  spec,

  getClientEndpoints,
  
  changeCase,
  preamble,
  capitalize,
  getFullAPIName,
  removeClientName,

  getNormalizedFieldName,
  getNormalizedDTOStructName,
  stringifyType,

  normalizeSchemaName,
  normalizePropName,
  normalizeMethodName,

  formatJsonProperty,
  formatAddQueryParam,
  formatAddHeaderParam,
  formatRouteArgument,
}
