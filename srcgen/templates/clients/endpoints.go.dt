{{
    const dotUtils = require('./dotUtils.js');
    const spec = dotUtils.spec;
    const clientName = "{{# def.clientName }}";
    const clientNormalizedName = "{{# def.clientNormalizedName }}";
}}
{{= dotUtils.preamble(clientName, spec.info.version) }}

import (
	"fmt"
	"net/http"
  "context"
    
	"github.com/Kyagara/equinox/api"
	"github.com/Kyagara/equinox/internal"
	"go.uber.org/zap"
)

{{
    const endpointGroups = dotUtils.getClientEndpoints(clientName);
    for (const [ endpointName, endpointMethods ] of Object.entries(endpointGroups)) {
        const endpoint = dotUtils.changeCase.pascalCase(endpointName);
        const normalizedStructName = dotUtils.removeClientName(endpoint);
}}
// # Riot API Reference
//
// [{{= endpointName }}]
//
// Note: this struct is automatically generated.
//
// [{{= endpointName }}]: https://developer.riotgames.com/apis#{{= endpointName }}
type {{= normalizedStructName }} struct {
	internalClient *internal.InternalClient
}

{{
    for (const [ route, path ] of endpointMethods) {
        for (const [ verb, operation ] of Object.entries(path)) {
            if (verb.startsWith('x-')) continue;

            const operationId = operation.operationId;
            let method = dotUtils.changeCase.pascalCase(operationId.slice(operationId.indexOf('.') + 1));
            method = dotUtils.normalizeMethodName(method);
            
            const resp200 = operation.responses['200'];

            /* Return type checks. */
            let hasReturn = false;
            let returnType = "";
            if (resp200 && resp200.content) {
                hasReturn = true;
                const jsonInfo = resp200.content['application/json'];
                returnType = dotUtils.stringifyType(jsonInfo.schema);
            }

            /* Body content checks. */
            let bodyType = null;
            if (operation.requestBody) {
                const jsonInfo = operation.requestBody.content['application/json'];
                bodyType = dotUtils.getNormalizedDTOStructName(dotUtils.stringifyType(jsonInfo.schema), endpointName.toUpperCase(), endpointName);
            }

            /* Build argument comment & string. */
            let normalizedRoute = dotUtils.changeCase.pascalCase(operation['x-route-enum']);
            normalizedRoute = normalizedRoute.replace("Regional", "api.Regional");
            normalizedRoute = normalizedRoute.replace("ValPlatform", "Platform");
            const argBuilder = ['ctx context.Context'];
            argBuilder.push('route ' + normalizedRoute + 'Route');

            /* Add body params before path/query. */
            if (bodyType) {
                argBuilder.push('body *' + bodyType);
            }

            /* Path and query params. */
            const allParams = operation.parameters;
            let queryParams = [];
            let headerParams = [];
            let routeArgument = "";
            if (allParams && allParams.length) {
                const pathParams = allParams.filter(p => 'path' === p.in)
                    .sortBy(({ name }) => route.indexOf(name));
                queryParams = allParams.filter(p => 'query' === p.in);
                headerParams = allParams.filter(p => 'header' === p.in);

                for (const paramList of [ pathParams, queryParams, headerParams ]) {
                    for (const param of paramList) {
                        argBuilder.push(dotUtils.normalizePropName(param.name) + " " + dotUtils.stringifyType(param.schema));
                    }
                }

                routeArgument = dotUtils.formatRouteArgument(route, pathParams);
            } else {
                routeArgument = dotUtils.formatRouteArgument(route);
            }

            const returnValue = dotUtils.getNormalizedDTOStructName(returnType, endpointName.toUpperCase(), endpointName);
            let isPrimitiveType = false;
            if (returnType === "int32" || returnType === "int64") {
              isPrimitiveType = true;
            }
            if (returnType === "float32" || returnType === "float64") {
              isPrimitiveType = true;
            }
            if (returnType === "string" || returnType === "[]string") {
              isPrimitiveType = true;
            }
            if (returnType.startsWith("map[") || returnType.startsWith("[]")) {
              isPrimitiveType = true;
            }

            /* Description processing. */
            const descArr = operation.description.replace("##", "#").replace(/\n\n/g, "\n").split('\n');

            for (const descLine of descArr) {
}}
//{{= descLine ? ' ' + descLine : '' }}
//
{{
            }
}}
// # Parameters
//   - `route` - Route to query.
{{
            if (allParams) {
              for (let param of allParams) {
                if (param.name === 'Authorization') param.name = "authorization";
}}
//   - `{{= param.name }}` ({{= param.required ? 'required' : 'optional' }}, in {{= param.in }}){{= param.description ? ' - ' + param.description : '' }}
{{
              }
  }
}}
//
// # Riot API Reference
//
// [{{= operationId }}]
//
// Note: this method is automatically generated.
//
// [{{= operationId }}]: {{= operation.externalDocs.url }}
func (e *{{= normalizedStructName }}) {{= method }}({{= argBuilder.join(', ') }}) {{= !hasReturn ? "error" : `(${isPrimitiveType ? "" : "*"}${returnValue}, error)` }} {
  logger := e.internalClient.Logger("{{= clientNormalizedName + "_" + normalizedStructName + "_" + method }}")
  logger.Debug("Method started execution")
  equinoxReq, err := e.internalClient.Request(ctx, logger, api.RIOT_API_BASE_URL_FORMAT, http.Method{{= dotUtils.capitalize(verb) }}, route, {{= routeArgument }}, "{{= operationId }}", {{? bodyType }}body{{?? true }}nil{{?}})
  if err != nil {
    logger.Error("Error creating request", zap.Error(err))
    return {{? hasReturn }}{{= isPrimitiveType ? `*new(${returnValue})` : "nil" }}, err{{?? true }}{{= isPrimitiveType ? `*new(${returnValue})` : "nil" }}{{?}}
	}
{{
  if (queryParams.length > 0) {
}}
  values := equinoxReq.Request.URL.Query()
{{
  }
}}
{{
  for (const queryParam of queryParams) {
}}
  {{= dotUtils.formatAddQueryParam(queryParam) }}
{{
  }
}}
{{
  if (queryParams.length > 0) {
}}
  equinoxReq.Request.URL.RawQuery = values.Encode()
{{
  }
}}
{{
  for (const headerParam of headerParams) {
}}
  {{= dotUtils.formatAddHeaderParam(headerParam, returnValue, isPrimitiveType) }}
{{
  }
}}
  {{? hasReturn }}var data {{= returnValue }}{{?}}
  err = e.internalClient.Execute(ctx, equinoxReq, {{? hasReturn }}&data{{?? true }}nil{{?}})
  if err != nil {
    logger.Error("Error executing request", zap.Error(err))
    return {{= isPrimitiveType ? `*new(${returnValue})` : "nil"}}{{? hasReturn }}, err{{?}}
  }
  logger.Debug("Method executed successfully")
  return {{? hasReturn }}{{= isPrimitiveType ? "data" : "&data" }}, nil{{?? true }}{{= isPrimitiveType ? `*new(${returnValue})` : "nil" }}
{{?}}
}

{{
            }
  }
}}
{{
    }
}}